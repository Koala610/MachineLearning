# -*- coding: utf-8 -*-
"""L4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17GTC8Ln-cuUnMGInKbr30mhUCw4VcDxv
"""

import cv2
import numpy as np
import os
import matplotlib.pyplot as plt
import sys

import tools as tl

print(sys.version)
print(np.__version__)
print(cv2.__version__)

"""# Init function"""

def getGradient(gray, x = 0, y = 0, useGradient = True):
    if useGradient:
        grad = cv2.Sobel(gray, ddepth=cv2.CV_32F, dx=x, dy=y, ksize=3)

        '''
            take absolute value of gradient to use negative gradient
        '''
        grad = np.absolute(grad)

        '''
            Normalization of gradient
        '''
        (minVal, maxVal) = (np.min(grad), np.max(grad)) 
        if maxVal - minVal > 0:
            grad = (255 * ((grad - minVal) / float(maxVal - minVal))).astype("uint8")
        else:
            grad  = np.zeros(gray.shape, dtype = "uint8")

    else:
        grad = cv2.adaptiveThreshold(  gray,
                                        255,
                                        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                        cv2.THRESH_BINARY_INV,
                                        11,
                                        2)

    return grad

"""# Process image"""

img = cv2.imread('11.jpg', 0)
vis = cv2.imread('11.jpg')
fig, ax = plt.subplots(figsize=(10, 10))
ax.imshow(img, cmap='gray')
plt.show()

bin_img = getGradient(img, x = 1, useGradient = True)
# fig, ax = plt.subplots(figsize=(15, 15))
# ax.imshow(bin_img, cmap='gray')
# plt.show()

verp = np.sum(bin_img, axis=1) / 255
drawedverp = tl.getDrawProjectionVer(img, verp)

"""## Find filter size"""

half = int(np.max(verp) / 2)
sliceLine = drawedverp[:,(half-1):(half+1)]
contours, hierarchy = cv2.findContours(cv2.cvtColor(   sliceLine, 
                                                       cv2.COLOR_BGR2GRAY), 
                                                       cv2.RETR_EXTERNAL, 
                                                       cv2.CHAIN_APPROX_SIMPLE)

print(half)

heights = []
for cnt in contours:
    x,y,w,h = cv2.boundingRect(cnt)
    heights.append(h)

medianHeight = int(np.median(np.asarray(heights)) * 1.5)
print("medianHeight", medianHeight)

drawedverp = cv2.line(drawedverp, 
                      (half,0), 
                      (half,drawedverp.shape[0]), 
                      (0,0,255), 
                      1)

"""## Convolve peaks"""

kernel = medianHeight
verpConvolved = np.convolve(verp, np.ones((kernel,))/kernel, mode='same')
drawedverpconv = tl.getDrawProjectionVer(img, verpConvolved)

"""## Find peaks"""

bandP1ranges = []
peaks = []
c1 = 0.2
c2 = 0.4
while np.max(verpConvolved) > 40:
    ybm = np.argmax(verpConvolved)

    yb0 = tl.findb0(verpConvolved, 
                    ybm, 
                    c1 * verpConvolved[ybm])
    yb1 = tl.findb1(verpConvolved, 
                    ybm, 
                    c2 * verpConvolved[ybm])

    if yb1 - yb0 > medianHeight:
        bandP1ranges.append((yb0,yb1))
        peaks.append((int(verpConvolved[ybm]), ybm))

    verpConvolved[yb0:yb1] = 0

# draw peaks
for peak in peaks:
    cv2.circle(drawedverpconv, peak, 5, (255,0,0), -1)

# draw bands
bandsImg = np.zeros(vis.shape, dtype = np.uint8)
for band in bandP1ranges:
    yt, yb = band
    bandsImg[yt:yb] = [0,255,0]

vis = cv2.addWeighted(vis, 0.6, bandsImg, 0.4, 0)

bigImg1 = tl.concat_hor((vis, drawedverp, drawedverpconv))
fig, ax = plt.subplots(figsize=(50, 50))
ax.imshow(bigImg1, cmap='gray')
plt.show()

